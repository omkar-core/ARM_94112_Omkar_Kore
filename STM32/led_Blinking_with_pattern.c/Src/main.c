/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#include "stm32f407xx.h"

#define BV(n) (1 << (n))

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

// LED Pin Definitions
#define LED_GREEN   12  // PD12
#define LED_ORANGE  13  // PD13
#define LED_RED     14  // PD14
#define LED_BLUE    15  // PD15

// LED Masks
#define ALL_LEDS    (BV(12) | BV(13) | BV(14) | BV(15))
#define PAIR1       (BV(12) | BV(14))  // Green + Red (opposite)
#define PAIR2       (BV(13) | BV(15))  // Orange + Blue (opposite)

// Pattern Definitions
typedef enum {
    PATTERN_ALL_BLINK,
    PATTERN_SEQUENTIAL,
    PATTERN_KNIGHT_RIDER,
    PATTERN_BINARY_COUNT,
    PATTERN_ALTERNATE_PAIRS,
    PATTERN_FILL_UP,
    PATTERN_FILL_DOWN,
    PATTERN_TWO_AT_TIME,
    PATTERN_RANDOM_LIKE,
    PATTERN_FAST_BLINK,
    PATTERN_COUNT  // Total number of patterns
} LedPattern;

// LED pins array for easy access
const uint8_t led_pins[4] = {LED_GREEN, LED_ORANGE, LED_RED, LED_BLUE};

// Function Prototypes
void led_init(void);
void led_on(void);
void led_off(void);
void led_set(uint8_t led_num);
void led_clear(uint8_t led_num);
void led_all_off(void);
void led_all_on(void);
void led_write(uint8_t value);

// Pattern Function Prototypes
void pattern_all_blink(void);
void pattern_sequential(void);
void pattern_knight_rider(void);
void pattern_binary_count(void);
void pattern_alternate_pairs(void);
void pattern_fill_up(void);
void pattern_fill_down(void);
void pattern_two_at_time(void);
void pattern_random_like(void);
void pattern_fast_blink(void);
void run_pattern(LedPattern pattern);

int main(void)
{
    led_init();

    LedPattern current_pattern = PATTERN_ALL_BLINK;
    uint32_t pattern_duration = 0;

    while(1)
    {
        // Run current pattern
        run_pattern(current_pattern);

        // Increment duration counter
        pattern_duration++;

        // Switch to next pattern after some iterations
        // Each pattern runs approximately 5 seconds
        if(pattern_duration >= 10)
        {
            pattern_duration = 0;
            current_pattern++;

            // Reset to first pattern after last one
            if(current_pattern >= PATTERN_COUNT)
            {
                current_pattern = PATTERN_ALL_BLINK;
            }

            // Turn off all LEDs when switching patterns
            led_all_off();
            DelayMs(200);
        }
    }
}

//=============================================================================
// LED Initialization Function
//=============================================================================
void led_init(void)
{
    //0. enable clock for GPIOD in AHB1
    RCC->AHB1ENR |= BV(3);

    //1. select mode as output (01 for each pin)
    GPIOD->MODER &= ~(BV(25) | BV(27) | BV(29) | BV(31));  // Clear bit 1 of each
    GPIOD->MODER |= BV(24) | BV(26) | BV(28) | BV(30);     // Set bit 0 of each

    //2. select type as push pull (0 for each pin)
    GPIOD->OTYPER &= ~(BV(12) | BV(13) | BV(14) | BV(15));

    //3. select speed as low (00 for each pin)
    GPIOD->OSPEEDR &= ~(BV(25) | BV(27) | BV(29) | BV(31));
    GPIOD->OSPEEDR &= ~(BV(24) | BV(26) | BV(28) | BV(30));

    //4. select pull up/down as no (00 for each pin)
    GPIOD->PUPDR &= ~(BV(25) | BV(27) | BV(29) | BV(31));
    GPIOD->PUPDR &= ~(BV(24) | BV(26) | BV(28) | BV(30));
}

//=============================================================================
// Basic LED Control Functions
//=============================================================================
void led_on(void)
{
    GPIOD->ODR |= BV(12) | BV(13) | BV(14) | BV(15);
}

void led_off(void)
{
    GPIOD->ODR &= ~(BV(12) | BV(13) | BV(14) | BV(15));
}

void led_set(uint8_t led_num)
{
    GPIOD->ODR |= BV(led_num);
}

void led_clear(uint8_t led_num)
{
    GPIOD->ODR &= ~BV(led_num);
}

void led_all_off(void)
{
    GPIOD->ODR &= ~ALL_LEDS;
}

void led_all_on(void)
{
    GPIOD->ODR |= ALL_LEDS;
}

// Write 4-bit value to LEDs (bit0=PD12, bit1=PD13, bit2=PD14, bit3=PD15)
void led_write(uint8_t value)
{
    GPIOD->ODR &= ~ALL_LEDS;
    GPIOD->ODR |= ((value & 0x0F) << 12);
}

//=============================================================================
// Pattern Runner
//=============================================================================
void run_pattern(LedPattern pattern)
{
    switch(pattern)
    {
        case PATTERN_ALL_BLINK:
            pattern_all_blink();
            break;

        case PATTERN_SEQUENTIAL:
            pattern_sequential();
            break;

        case PATTERN_KNIGHT_RIDER:
            pattern_knight_rider();
            break;

        case PATTERN_BINARY_COUNT:
            pattern_binary_count();
            break;

        case PATTERN_ALTERNATE_PAIRS:
            pattern_alternate_pairs();
            break;

        case PATTERN_FILL_UP:
            pattern_fill_up();
            break;

        case PATTERN_FILL_DOWN:
            pattern_fill_down();
            break;

        case PATTERN_TWO_AT_TIME:
            pattern_two_at_time();
            break;

        case PATTERN_RANDOM_LIKE:
            pattern_random_like();
            break;

        case PATTERN_FAST_BLINK:
            pattern_fast_blink();
            break;

        default:
            pattern_all_blink();
            break;
    }
}

//=============================================================================
// Pattern 1: All LEDs Blink Together
//=============================================================================
void pattern_all_blink(void)
{
    led_on();
    DelayMs(500);
    led_off();
    DelayMs(500);
}

//=============================================================================
// Pattern 2: Sequential (One LED at a time, circular)
//=============================================================================
void pattern_sequential(void)
{
    uint8_t i;

    for(i = 0; i < 4; i++)
    {
        led_all_off();
        led_set(led_pins[i]);
        DelayMs(200);
    }
}

//=============================================================================
// Pattern 3: Knight Rider (Bounce back and forth)
//=============================================================================
void pattern_knight_rider(void)
{
    static int8_t index = 0;
    static int8_t direction = 1;

    led_all_off();
    led_set(led_pins[index]);
    DelayMs(150);

    index += direction;

    if(index >= 3)
    {
        index = 3;
        direction = -1;
    }
    else if(index <= 0)
    {
        index = 0;
        direction = 1;
    }
}

//=============================================================================
// Pattern 4: Binary Counter (0 to 15)
//=============================================================================
void pattern_binary_count(void)
{
    static uint8_t count = 0;

    led_write(count);
    DelayMs(400);

    count++;
    if(count > 15)
    {
        count = 0;
    }
}

//=============================================================================
// Pattern 5: Alternate Pairs (Opposite LEDs together)
//=============================================================================
void pattern_alternate_pairs(void)
{
    // Pair 1: Green (PD12) + Red (PD14)
    led_all_off();
    GPIOD->ODR |= PAIR1;
    DelayMs(300);

    // Pair 2: Orange (PD13) + Blue (PD15)
    led_all_off();
    GPIOD->ODR |= PAIR2;
    DelayMs(300);
}

//=============================================================================
// Pattern 6: Fill Up (Accumulate LEDs one by one)
//=============================================================================
void pattern_fill_up(void)
{
    uint8_t i;

    led_all_off();

    // Turn on LEDs one by one
    for(i = 0; i < 4; i++)
    {
        led_set(led_pins[i]);
        DelayMs(150);
    }

    DelayMs(200);

    // Turn off all at once
    led_all_off();
    DelayMs(200);
}

//=============================================================================
// Pattern 7: Fill Down (Deplete LEDs one by one)
//=============================================================================
void pattern_fill_down(void)
{
    uint8_t i;

    // Start with all LEDs on
    led_all_on();
    DelayMs(200);

    // Turn off LEDs one by one
    for(i = 0; i < 4; i++)
    {
        led_clear(led_pins[i]);
        DelayMs(150);
    }

    DelayMs(200);
}

//=============================================================================
// Pattern 8: Two LEDs at a Time (Sliding window)
//=============================================================================
void pattern_two_at_time(void)
{
    // Green + Orange
    led_all_off();
    led_set(LED_GREEN);
    led_set(LED_ORANGE);
    DelayMs(250);

    // Orange + Red
    led_all_off();
    led_set(LED_ORANGE);
    led_set(LED_RED);
    DelayMs(250);

    // Red + Blue
    led_all_off();
    led_set(LED_RED);
    led_set(LED_BLUE);
    DelayMs(250);

    // Blue + Green
    led_all_off();
    led_set(LED_BLUE);
    led_set(LED_GREEN);
    DelayMs(250);
}

//=============================================================================
// Pattern 9: Random-like Sequence
//=============================================================================
void pattern_random_like(void)
{
    // Pre-defined sequence that looks random
    static const uint8_t sequence[] = {
        0x09,  // Green + Red
        0x06,  // Orange + Blue (shifted)
        0x05,  // Green + Blue
        0x0A,  // Orange + Red
        0x0F,  // All ON
        0x03,  // Green + Orange
        0x0C,  // Red + Blue
        0x00   // All OFF
    };
    static uint8_t idx = 0;

    led_write(sequence[idx]);
    DelayMs(200);

    idx++;
    if(idx >= 8)
    {
        idx = 0;
    }
}

//=============================================================================
// Pattern 10: Fast Blink (Strobe effect)
//=============================================================================
void pattern_fast_blink(void)
{
    uint8_t i;

    for(i = 0; i < 5; i++)
    {
        led_all_on();
        DelayMs(50);
        led_all_off();
        DelayMs(50);
    }

    DelayMs(200);  // Pause between bursts
}





